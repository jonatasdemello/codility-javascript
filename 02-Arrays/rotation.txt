given an array A consisting of N integers and an integer K,
returns the array A rotated K times.

A = [3, 8, 9, 7, 6]
K = 3

Output
[9, 7, 6, 3, 8]

Explanation
Rotation 1 => [3, 8, 9, 7, 6] -> [6, 3, 8, 9, 7]
Rotation 2 => [6, 3, 8, 9, 7] -> [7, 6, 3, 8, 9]
Rotation 3 => [7, 6, 3, 8, 9] -> [9, 7, 6, 3, 8]

K (rotation)

* if K < arr.length, then K is the new index of the first element:

K = 3
idx  0  1  2  3  4
A = [3, 8, 9, 7, 6]
O = [9, 7, 6, 3, 8]
     |________^

* if K > arr.length, then use (K MOD arr.length)
    we need to use the "modulus" (the remainder of a division)
    as the new index of the first element:

K: 6 A: [ 1, 2, 3, 4, 5 ] A.length: 5 (K % arr.length): 1  => first element new index

i: 1 A: [ 5, 1, 2, 3, 4 ]
i: 2 A: [ 4, 5, 1, 2, 3 ]
i: 3 A: [ 3, 4, 5, 1, 2 ]
i: 4 A: [ 2, 3, 4, 5, 1 ]
i: 5 A: [ 1, 2, 3, 4, 5 ]
i: 6 A: [ 5, 1, 2, 3, 4 ]

the result is the original array

K=3 split the arry at (k-1) pos[2] : [3, 8] and [9, 7, 6]
join: [9, 7, 6] + [3, 8]

K: 3 A: [ 3, 8, 9, 7, 6 ] A.length: 5 (K % arr.length): 3  => first element new index
i: 1 A: [ 6, 3, 8, 9, 7 ]
i: 2 A: [ 7, 6, 3, 8, 9 ]
i: 3 A: [ 9, 7, 6, 3, 8 ]

if k > arr.length then
    R = K % arr.length
    idxLeft = arr.length - R
    idxRight = idxLeft - 1

split the array: L = [0..R] , R = [idxLeft..arr.length]
new array: R .. L

val rotation = k % nums.size
val l = nums.size - rotation
val r = l - 1
return nums.slice(l until nums.size) + nums.slice(0..r)

fun solution(A: IntArray, K: Int): IntArray {
    if (A.isEmpty() || A.size == K || K == 0) return A

    val r = K % A.size
    val L = A.size - r
    val R = L - 1
    
    return (A.slice(L until A.size) + A.slice(0..R)).toIntArray()

}

Time complexity: O(N) Where n is the number of elements in the input array nums. This is because we are iterating through the array twice, once to copy the elements to a new array and once to update the original array with the rotated elements.
Space complexity: O(N) We are creating a copy of the input array nums with the same size, which requires additional space.

idx  A: [ 0, 1, 2, 3, 4 ]
----------------------------------------

K: 3 A: [ 3, 8, 9, 7, 6 ] A.length: 5 (K % arr.length): 3  => first element new index
i: 1 A: [ 6, 3, 8, 9, 7 ]
i: 2 A: [ 7, 6, 3, 8, 9 ]
i: 3 A: [ 9, 7, 6, 3, 8 ]

----------------------------------------

K: 1 A: [ 1, 2, 3, 4, 5 ] A.length: 5 (K % arr.length): 1  => first element new index
i: 1 A: [ 5, 1, 2, 3, 4 ]

----------------------------------------

K: 2 A: [ 1, 2, 3, 4, 5 ] A.length: 5 (K % arr.length): 2  => first element new index
i: 1 A: [ 5, 1, 2, 3, 4 ]
i: 2 A: [ 4, 5, 1, 2, 3 ]

----------------------------------------

K: 3 A: [ 1, 2, 3, 4, 5 ] A.length: 5 (K % arr.length): 3  => first element new index
i: 1 A: [ 5, 1, 2, 3, 4 ]
i: 2 A: [ 4, 5, 1, 2, 3 ]
i: 3 A: [ 3, 4, 5, 1, 2 ]

----------------------------------------

K: 4 A: [ 1, 2, 3, 4, 5 ] A.length: 5 (K % arr.length): 4  => first element new index
i: 1 A: [ 5, 1, 2, 3, 4 ]
i: 2 A: [ 4, 5, 1, 2, 3 ]
i: 3 A: [ 3, 4, 5, 1, 2 ]
i: 4 A: [ 2, 3, 4, 5, 1 ]

----------------------------------------

K: 5 A: [ 1, 2, 3, 4, 5 ] A.length: 5 (K % arr.length): 0  => first element new index
i: 1 A: [ 5, 1, 2, 3, 4 ]
i: 2 A: [ 4, 5, 1, 2, 3 ]
i: 3 A: [ 3, 4, 5, 1, 2 ]
i: 4 A: [ 2, 3, 4, 5, 1 ]
i: 5 A: [ 1, 2, 3, 4, 5 ]

----------------------------------------

K: 6 A: [ 1, 2, 3, 4, 5 ] A.length: 5 (K % arr.length): 1  => first element new index
i: 1 A: [ 5, 1, 2, 3, 4 ]
i: 2 A: [ 4, 5, 1, 2, 3 ]
i: 3 A: [ 3, 4, 5, 1, 2 ]
i: 4 A: [ 2, 3, 4, 5, 1 ]
i: 5 A: [ 1, 2, 3, 4, 5 ]
i: 6 A: [ 5, 1, 2, 3, 4 ]
